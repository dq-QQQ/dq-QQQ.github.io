---
title: C++의 기초
categories:
  - Language
excerpt: "cpp의 기초를 공부해보자:)"
date: 2022-05-17
tags:
- C++
---


# 개요

---

반복문, 조건문 같은 다른언어에도 있는 cpp의 기초에 대해서 알아보겠다.

기초이기 때문에 다 정리하기보다 새로배운, 헷갈리는 개념들만 정리했다.

<br />
<br />

---

# Cpp란

---

C의 절차적 언어 + 클래스를 추가한 객체지향 언어 + 템플릿이 지원하는 일반화 프로그래밍언어

<br />
<br />

---

# 변수

---

* 변수 이름에는 영문자, 숫자, 밑줄문자만 사용가능
* 숫자를 변수 이름의 첫문자로 사용 불가능
* 변수이름에서 대소문자 구별
* c++ 키워드는 변수이름으로 사용 불가능
* __ 혹은 _대문자로 시작하는 이름은 컴파일러와 리소스가 사용함
* _로 시작하는 이름은 컴파일러와 리소스가 전역 식별자로 사용함


<br />
<br />

---

# 상수

---

상수로 선언하면 컴파일러는 값을 변경하려하지 않는다.

상수는 선언과 동시에 초기화해야한다.



<br />
<br />

---

# 자료형

---

int형은 컴퓨터에서 가장 자연스럽고 효율적인 정수 크기로 설정된다.

따라서 가급적이면 int로 선언한다.

숫자 앞에 `0x`를 붙이면 16진수 정수이고 `0`을 붙이면 8진수 정수로 저장된다.

`cout << hex;`를 하면 출력하는 진수를 바꾼다.

auto를 사용하면 자동으로 자료형을 정한다. STL에서 유용하게 쓰인다.

<br />
<br />

---

# 형변환

---

작은 데이터로 초기화 해도 큰 데이터 타입으로 들어간다.

`(long) example`와 `long (example)`이 있다.

앞은 C 스타일 뒤는 C++ 스타일이다.

<br />
<br />

---

# 구조체

---

C언어에서는 초기화 할때 sturct 키워드를 붙이고 해야하지만 c++은 안해도된다.

`struct 구조체이름 구조체변수`는 C

`구조체이름 구조체변수`는 C++


<br />
<br />

---

# 공용체

---

서로다른 자료형을 한 번에 한가지만 보관할 수 있는 데이터형

공용체의 크기는 가장 큰 멤버의 크기가된다. 메모리의 절약을 위해 사용한다.

<br />
<br />

---

# 열거체

---

const로 기호상수를 만드는 다른 방법이다.

이것들로 산술 연산은 허용되지 않는다. 숫자 + 열거체는 가능.

<br />
<br />

---

# new

---

선언에 의해 배열을 생성하면 컴파일 할 때 만들어지고 정적 바인딩이라고 함

new를 이용하면 실행시간에 생성되고 동적 바인딩이라고함

<br />
<br />

---

# 배열의 대안

---


* Vector 템플릿 : 동적배열
* array 템플릿 : 정적배열

<br />
<br />

---

# bool

---

`cout.setf(ios_base::boolalpha);`를 적으면 1, 0이아니라 true, false를 출력


<br />
<br />

---

# switch

---

선택 사항이 3개 이상이면 swit초 쓰는게 실행속도면에서 효율적

<br />
<br />

---

# 함수 프로시저

---

엄밀히 말하면 리턴값이 있으면 함수 없으면 프로시저 근데 그냥 다 함수라고 부름

<br />
<br />

---

# 함수원형을 사용해야하는 이유

---

* 함수원형은 컴파일러에게 함수의 인터페이스를 미리 알려준다.
* 계산을 끝냈을 때 리턴값을 어떤 지정된 위치에 넣고 값을 가져온다. 미리 알려줘야 몇바이트 꺼내고 어떻게 처리해야하는 지 안다.

<br />
<br />

---

# 포인터와 const

---


```c++
// 사용가능 그러나 값은 변경 불가능
int age = 25;
const int *pt = &age;

const int earth = 9;
const int *p =  &earth;

// 사용불가능
const int moon = 2;
int *p = &moon;
```

**가능하면 const를 사용하라**

```c++
int sloth = 3;
const int *ps = &sloth; // const int를 가리키는 포인터
int * const finger = &sloth; // int를 지시하는 const 포인터
const int * const p = &sloth; // const int를 가리키는 const 포인터
```

<br />
<br />

---

# 이름 공간

---

C++에서는 이름의 사용범위를 더욱 잘 제어할 수 있도록 이름 공간이라는 기능을 제공한다.

이름 공간은 전역위치 또는 다른 이름 공간 안에 넣을 수 있지만 블록 안에는 놓을 수 없다.

이름 공간에 속해있는 이름에 접근하려면 사용 범위 결정 연산자인 ::를 이용한다.

사용할 때마다 제한하는 것은 귀찮으므로 using 선언과 using 지시자라는 두가지 방법을 제공한다.

using 선언은 하나의 특별한 식별자를 사용할 수 있게 만들고, using 지시자는 그 이름 공간 전체에 접근할 수 있게 만든다.

`using Q::fetch;`를 선언하면 그 이후는 fetch만으로 사용가능하다.

using 지시자는 `using namespace q`라고 사용하며 이름공간에 속한 모든 이름을 사용할 수 있다.

그러나 이것들은 이름 충돌의 가능성을 증가시긴다.

그러므로 전역 이름공간을 만들기보단 using 선언을 사용하여 필요한 것만 사용하는 것이 좋다.

이름공간 안에 이름공간을 중첩해서 선언할 수 있다. `q::kyu::jin`와 같이 사용할 수 있다.

이름공간의 이름을 생략하면 이름없는 이름공간이 만들어진다.

그러므로 ::없이도 접근할 수 있다.

<br />
<br />

---

# 이름 공간 사용 가이드라인 

---

* 정적, 외부 전역변수를 사용하지 말고 이름이 명명된 이름 공간에 있는 변수를 사용
* 함수 또는 클래스 라이브러리를 개발한다면 하나의 이름 공간안에 넣어라
* using 지시자는 왠만하면 사용하지 마라
* using 지시자를 헤더에 사용하지마라
