---
title: ejik
categories:
  - iOS
excerpt: ":)"
date: 2025-01-01
tags:
- iOS-PRO
---


# 개요

## Objective-C → Swift 전환 프로젝트 관련

### 3만 라인 전환 시 가장 어려웠던 상호 운용성(Interoperability) 문제는 무엇이었으며, 어떻게 해결했나요? 

- 가정 어려웠던 점은 ObjC의 동적 디스패치와 런타임의 유연함에 의존하던 레거시 로직을 엄격한 정적 디스패치 타입과 타입 시스템으로 옮기는 과정이었습니다.

### objc_msgSend를 대체하기 위해 Static Dispatch 기반 Custom VTable을 설계했다고 하셨는데, 구체적인 설계 방식과 이를 통해 얻은 성능 이득은 무엇인가요? 

-  objc는 함수 호출이 메시징 기반으로 objc_msgSend를 사용하기 때문에 런타임에 메서드를 찾는다.
-  그러나 swift는 VTabel이나 Static Dispatch를 사용하여 컴파일 타임에 호출할 주소를 찾는다.
-  기존 objc에서는 웹에서 string으로 함수명이 넘어오면 objc_msgsend로 어떤 메서드든 실행가능
-  스위프트에서는 그게 안된다 그러나 모든 호출을 if else로 분기 처리하기엔 관리 포인트가 너무 많아졌다.
-  따라서 명령어 문자열과 클로저 형태의 실행 로직을 매핑하는 구조를 만들고 각 클래스 별로 init할 때 등록함
-  해당 클래스 맵을 웹뷰에서 들고있으며 명령이 들어오면 해당 기능를 객체의 테이블에서 찾음
-  objc_msgSend는 매번 클래스 계층구조를 타고 올라가며 셀렉터를 찾지만, hash table에서 키밸류 형태로 하여 검색이 o(1)로 오버헤드가 없음
-  Swift에서도 @objc_dynamic이라는 키워드로 쓸수있었지만, 저는 Swift 전환하는 목적중 하나가 런타임의 불확실성을 제거하고 성능을 최적화하는 것이었음
-  그래서 조금 번거롭더라도 직접 테이블 구조를 설계하여 컴파일 시간에 메서드 호출 타이밍을 정하는 스위프트의 특성을 살리려고 노력햇음

### 전환 후 코드 라인 수를 30% 줄였는데, Swift의 어떤 문법적 특성이 이를 가능하게 했나요? 

-  h,m을 나누어 작성하고 인터페이스와 구현부를 따로 하던거를 합친거
-  기존에 타입별로 각각 구현한 것을 제네릭으로 공통화, 웹뷰 메시지 처리시의 프로토콜기반의 룩업 테이블로 대체
-  고차함수
-  swift concurrency 도입
-  구조체 적극 활용(initalizer) 생성 불필요 값타입



## 메모리 및 성능 관리

### MRC 환경에서 C++ 코어 로직과 객체 생명주기를 동기화할 때 발생한 메모리 누수 위험을 어떻게 관리했나요? 

-  c++ 객체는 힙 메모리에 생성되어 수동으로 delete를 호출해야하지만 objc-C객체는 그게 아님
-  c++ 객체의 생명주기를 objc 객체의 생명주기에 종속시킴 init에서 cpp객체도 만들고 dealloc될때 delete되게 함
-  그리고 cpp로직으로 objc 객체를 보내기 전에 retain을 하고 그 뒤에 release를 함



### Instruments를 활용해 하이라이트된 Hang이나 Frame drop 이슈를 해결한 구체적인 사례가 있나요? 

-  버그중 하나인데 잘못된 url로 쐇을때 리턴을 바로 안준다 왜냐면 보냈을때 얘가 서버가 잇는데 무응답인거랑 아예 없는지를 알수가 없기때문에 타임아웃을 기다림
-  cpp 핵심 로직을 타기 때문에 그동안 화면이 멈추는 hang이 걸렷음 따라서 비동기로 처리함
-  불필요한 레이아웃 재계산이 프레임드랍의 원인이 됨 매번 layoutIfNeeded를 강제 호출해서 동기적으로 레이아웃을 잡는대신 setNeedsLayout으로 사용함
-  


## 비동기 처리 및 아키텍처

### 서버 통신 시 발생한 '콜백 지옥'을 Swift Concurrency로 리팩토링할 때, 기존 Combine이나 GCD 방식과 비교해 어떤 이점이 있었나요? 

-  신규앱 개발당시 서버 통신 -> 암복호화 -> 서버통신 -> 로컬 DB저장 -> UI업데이트로 이어지는 연속적인 비동기 로직
-  특히 모든 클로저마다 에러처리를 중복해서 작성해야함
-  Combine은 선언적으로 처리할 수 잇어 깔끔해졌지만 로직이 복잡해질수록 하나의 코드 블럭으로 끝내야하는게 흐름을 쫒아가기 힘들었음
-  단일 비동기일때에도 불필요하게 스트림을 생성해야한다는게 에바쎄바
-  asyncawait은 선형적인 코드 작성이 되었음
-  에러 처리를 중앙 집중화 가능함
-  gcd방식은 개발자가 실수로 UI를 백그라운드에서 업데이트 할 위험이잇었음 이건 런타임에 발견됨
-  swift concurrency의 @MainActor로 ui 업데이트 코드를 컴파일 타임에 체크할 수 있었음
-  gcd는 작업이 블로킹 될때마다 새로운 스레드를 생성하여 스레드 폭발이 일어날 위험이 있음
-  그러나 swift concurrency는 코어 개수에 맞춰 스레드를 제한적으로 관리
-  gcd로 작업을 던지면 시스템은 스레드 풀에서 노는 스레드가 잇는지 확인함 없으면 만듬
-  만약 실행중인 작업들이 네트워크 요청같은걸로 블락 되면 시스템은 작업 처리를 위해 새로운 스레드를 생성
-  스레드는 약 512kb~ 1mb의 스택메모리를 점유 그럼 스레드가 100개면 100메가 정도의 메모리를 생성함
-  작업을 위해 스레드를 늘리는게 gcd
-  앱이 실행되면 기본적으로 하나의 프로세스 메모리 공간을 가짐
-  여기서 gcd가 새로운 스레드를 만들면 각 스레드가 자기만의 로직을 실행할 수 잇도록, 프로세스의 공용 메모리 구역중 스택영역의 일부를 떼어줌
-  코드는 앱의 바이너리 크기와 직접적으로 연괌됨 앱 실행시에 램에 로드됨 (10메가 ~ 수백메가)
-  데이터는 전역이나 static이 저장되어 매우 작음 1~10메가 static은 lazy 할당 방식으로 실제 접근 시점에 로드됨
-  스택은 함수 호출 시 지역변수 복귀주소등을 저장함
-  힙은 앱 메모리의 대부분임 클로저 클래스 이미지 네트워크등 내가 대충 생각하는 데이터들이 여기에 동적으로 할당됨
-  잠깐 딴길로샛음
-  await을 만나면 현재 실행중이던 함수는 그 즉시 cpu 사용권을 내려놓는다.
-  그럼 시스템은 그걸 위임받아 알아서 돌림 그리고 그 일을 하던 스레드는 스레드 풀로 돌아가 다른 작업을 함
-  gcd엿으면 스레드가 램의 스택 공간을 통째로 잡고 잠들엇지만 sc는 필요한 정보만 힙으로 보냄
-  현재 함수의 지역 변수 값, 다음에 실행해야할 코드 위치등을 담은 continuation 객체를 생성해서 힙에 저장
-  스택은 해당 스레드가 꽉 잡고 잇는 공간이지만 힙은 모든 스레드가 공유하는 공간임
-  따라서 나중에 다른 스레드가 해당 정보를 가져와서 작업을 이어나갈 수 있음
-  스레드 폭발이 앵간해서 없음
-  aysnc 함수 내부에서 await이 아니라 thread.sleep나 무한 루프등 동기적 블로킹을 하면
-  스레드가 굳어버림 cpu는 점유하고잇는데 일은 안하고잇음 gcd는 스레드를 더 만들어서 대응햇겟지만 sc는 아님
-  await 전후의 데이터값을 보장할 수 없음 따라서 가변 데이터 같은 경우는 actor를 활용해야함
-  너무 가벼운 작업은 힙에 저장하고 스케쥴링 하는 비용이 더 비쌈 그래서 코드를 매우 잘짜야됨
-  너무 무거운 연산은 Task.detached같은 것으로 스레드를 양보하도록 설계해야됨
-  await은 단순한 대기가 아니라 상태가 변할 수 있는 틈
-  따라서 actor를 써야하는데 내부적으로 직렬 큐처럼 동작함
-  한번에 하나의 task만 접근할 수 있도록 보장
-  actor 내부 함수에서 await을 호출하면 잠시 중단될때 다른애들이 접근할 수 잇음 따라서 중요 상태 변경로직은 동기로 묶어서 처리
-  actor안에 잇지만 굳이 보호받을 필요없을때는 nonisolated

### Swift6

-  스위프트 6의 핵심은 데이터 레이스를 원천적으로 차단하게되엇음
-  이전에는 잠재적 동시성 오류들이 컴파일 에러로 처리됨
-  서로 다른 격리구역으로 데이터가 전달될때 데이터가 안전하게 복사되거나 공유될 수 잇는지 Sendable을 엄격하게 검사함
-  서로 다른 격리구역이란 actor나 스레드가 다를 때임
-  불변성이나 격리가 보장되어야함 이는 값타입이어야됨 final 클래스인데 모두 상수로 되어있으면 됨
-  Actor는 직렬 접근을 보장하니깐 그 자체로 Sendable임
-  @Sendable 키워드를 붙여서 클로저가 캡쳐한 변수들이 스레드간 이동에 안전함을 보장해야됨
-  클래스 객체를 비동기 Task에 담아 보낼때 오류가 뜨는데 값타입을 왠만해선 쓰거나 Actor로 선언하엿음
-  외부 라이브러리같이 수정이 불가능한 경우 preconcurrency를 사용하거나 데이터 레이스가 없음을 확신할 때 nonisolated(unsafe)를 사용함
-  그래도 보내야할 때가 필요하다면 클래스 인스턴스 자체를 보내지말고 실제 필요한 정보만 추출해서 보냄

### 현재 개인 프로젝트에서 **TCA(The Composable Architecture)**로 리팩토링 중이신데, MVVM에서 TCA로 넘어가려는 명확한 이유가 무엇인가요? 

-   앱이 커지면 여러개의 뷰모델이 하나의 뷰에서 각자의 상태를 가짐
-   특정 이벤트가 발생했을 때 여러 뷰모델의 상태를 동시에 업데치트해야한다면 추적하기가 매우어려움
-   기능단위 state로 관리함 모든 변화는 액션을 통해야하고 리듀서에서만 처리함 누가 언제 왜 이값을 바꿨는지를 찾기 쉬움
-   mvvm은 뷰모델 내부에서 함수가 함수를 부르고 그 안에서 다시 상태를 바꾸는등 데이터 흐름이 양방향임
-   action->reducer -> state update -> View로 이어지는 단방향 데이터 흐름임


### 암호화 알고리즘 경량화를 통해 QR 인식률을 높였다고 하셨는데, 보안성과 인식 속도 사이의 트레이드오프를 어떻게 조율했나요? 

-  기존의 무거운 공개키 방식 위주에서 대칭키 방식을 혼합하거나 EC 알고리즘으로 전환하여 보안성은 유지하면서 연산량을 줄엿습니다.
-  body를 검증하기 전 헤더 정보를 검사하여 유효하지 않으면 드랍하는 예외처리
-  Swift Concurrency 적용
-  aes는 대칭키 암호화이다 암복호화를 같은 키를 사용한다. 상대방에게 키를 안전하게 전달하는 것이 어려움
-  rsa는 비대칭키 암호화. 공개키로 잠그고 개인키로만 열 수 있음
-  이걸 내가 제안하진 않았다 안드로이드, 서버도 동일한 알고리즘으로 암복호화를 해야했기때문에 신입에겐 뭔가를 할 수 없었다
-  그러나 rsa 위주의 기반의 암복호화 로직을 ec로 바꾸는 것을 전담했고 실제 qr 인식률이 얼마나 좋아졌는지 검증하는 과정을 주도함


#### 플러터 경험이 전혀 없었음에도 고객사 요청에 대응하기 위해 샘플을 제작했습니다. 생소한 기술 스택을 빠르게 익히는 본인만의 노하우가 있나요? 

-   핵심 매커니즘의 공통점을 찾습니다.
-   모든 문법과 api를 익힌다기보다 제가 알고있는 iOS 기술 스택에서의 공통점과 차이점을 먼저 파악합니다.
-   플러터를 처음 접햇을 때 제가 알고 있는 SwiftUI의 선언형 ui와 비슷하였고 상태 변화에 따라 UI가 다시그려지는 이런 핵심원리부터 파악합니다.
-   그리고 가장 작은 단위 뷰를 빠르게 구현해보며 큰 구조와 작은 구조를 반복하며 최대한 익숙해지려고 합니다.
-   그리고 이 과정에서 궁금했던 것들은 제 개인 블로그에 적어놓습니다. 일단 진행하고 나중에 보면 자동으로 습득되는 질문들도 많기 때문이다
-   저에게 새로운 기술은 단지 처음 접하기 때문에 익숙하지 않은것이라고 생각합니다. 이처럼 어떤 환경에서도 핵심을 빠르게 짚어내는 인사이트를 가지고 있는 개발자입니다.


#### 관리자에게 기술 부채 해소(Swift 전환)의 중요성을 설득했다고 하셨는데, 어떻게 했나여

-  결정권자에게 코드가 단지 더럽다는 이유로의 접근은 통하지 않았습니다.
-  신입의 입장에서 바라본 제품을 솔직하게 말씀드렸다 신규 입사자가 적응하는데에 오래걸린다 더군다나 저 전에 취업한 사람도 스위프트 하고싶다고 나간전적이 있었기에 설득이 쉬웠다
-  스위프트 특성상 런타임 크래시를 획기적으로 줄일수 잇다고 햇다. 그리고 처음부터 하는게 아니라 하나의 프로젝트에서 바텀 업방식으로 하는 예시를 보여드리면서 했다.


#### "디테일이 신뢰를 만든다"는 철학이 실제 코드 작성 시 어떻게 투영되나요? 

-  불안 요소를 사전에 제거하여 신뢰를 구축하는 것
-  주석
-  사소한것


#### iOS를 넘어 안드로이드, 웹, 서버까지 다루는 개발자를 지향하신다고 했는데, 현재 이를 위해 구체적으로 준비하고 있는 것이 있나요?

-  언어와 특정 플랫폼 지식을 넘어서는 CS의 본질을 보려고 한다.
-  단순히 Swift Concurrency가 좋은 건 알겠다. 사용방법도 알겠다. 거기에서 그치는 것이 아니라 왜 그러는지 본질을 파악하려고 노력한다.
-  그러다 보면 웹이든 서버든 안드로이드든 본질은 똑같다는 것을 알게 되고 나중에는 큰 틀을 설계할 수 있는 능력을 가질수잇다고 생각한다.
-  현재는 iOS에 집중하고 있으며 계획으로는 Todaypic 개인프로젝트의 안드로이드와 서버를 직접 구현해서 하나의 큰 서비스를 만들어보는 계획을 향후 1년, 2년 안에 가지고있다.

## iOS 질문

### 컴퓨터 시스템에서 CPU, RAM, 저장 장치의 역할과 이들이 어떻게 상호 작용하는지 설명해주세요.

-  사용자가 앱을 실행하면 스토리지에 잇던 데이터가 램으로 올라온다
-  cpu는 램에 올라온 데이터 중 지금 당장 필요한 명령어를 가져와서 해독한다.
-  해석된 명령에 따라 cpu가 계산을 한다
-  처리된 결과는 램에 다시 기록됨


#### 저장 장치에서 앱 바이너리 로드

-  운영체제가 사용자의 앱 실행 요청을 감지
-  저장 스토리지에서 해당 앱의 바이너리 위치를 찾는다
-  os는 램에 이 앱이 올라올 수 잇는 빈 공간을 확보한다.
-  저장장치에 있는 바이너리 데이터를 일정한 크기로 나누어 램으로 복사한다.
-  당장 실행에 필요한 부분만 먼저올림
-  앱이 사용하는 외부라이브러리, 다이나믹 라이브러리와 실제 메모리 주소를 연결한다.
-  cpu의 프로그램 카운터가 램에 로드된 앱의 엔트리 포인터를 가리키며 한줄씩 실행된다.
-  따라서 앱 로딩이 너무 느리다면 바이너리에 포함된 라이브러리가 너무 많아서 로딩과 주소 연결이 오래걸리는것

#### RAM에 코드와 초기 데이터 적재

-  cpu가 실행하는 코드는 메모리 주소 어디에 있는 값을 읽어와이지만 실제 램 주소가 아님
-  os는 가상 주소와 실제 램의 주소를 짝지어놓은 페이지 테이블을 가지고 잇음
-  랜덤 액세스 메모리라서 파편화가 발생할 수 잇음
-  iOS 시스템 라이브러리는 모든 앱이 공통으로 사용함 램의 특정 구역에 미리 올려두고 사용중임
-  iOS는 메모리가 부족할 때 스왑하지 않고 그냥 램에서 밀어버림

### RAM이 부족하면 iOS 시스템은 어떤 동작을 할까요? 이것이 앱 개발 시 왜 중요할까요?

-  먼저 시스템은 저장장치로부터 다시 읽어올 수 잇는 데이터부터 메모리에서 날려버림(실행파일, 이미지, 프레임워크등)
-  그래도 부족하면 dirty page(heap)을 압축함
-  그래도 부족하면 메모리를 가장 마니 쓰는 앱부터 강제 종료
-  didReceiveMemoryWarning을 통해 많이 쓰는 힙을 비워주는 작업을 하면 조금이나마 줄일수잇음

#### CPU 속도, RAM 용량, 저장 장치 속도 중 어떤 것이 앱의 '체감 속도'에 가장 큰 영향을 미칠 수 있을까요? 이유와 함께 설명해주세요.

-  1위 저장장치 속도 : 일단 램으로 적재를 해야하는데 그 시간이 오래걸리면 체감이 오래걸림
-  2위 램 : 그렇게 체감이 될까?
-  3위 스크롤하거나 데이터를 처리할 때속도임

#### 그럼 램이 늘어나면 스레드의 크기도 늘어남?

-  스레드의 크기는 메인 1메가 백그라운드 512kb로 고정 따라서 개수가 늘어남

#### iOS의 A-시리즈 칩셋에서 CPU와 GPU가 메모리를 공유하는 Unified Memory Architecture가 앱 개발에 미치는 영향은 무엇인가요?

- 일반 pc는 ram과 vram이 물리적으로 분리되어잇음 따라서 복사해야됨
- iOS는 동일한 메모리 공간을 바라봐서 복사할 필요가없음
- cpu가 놀고있을때 ram을 다른용도로 gpu가 놀고 잇을때 vram을 다른 용도로 못쓰지만 동적으로 효율적으로 나눠씀
- iOS에서는 가속이라는 개념이 있는데 예를들어 이미지 처리 가속같은거다 그게 가능한 이유다.
- 자원공유로 인한 대역폭 경쟁과 용량한계가 단점임 따라서 pc같이 고성능이고 무거운 작업을 하는 곳에서는 비효율적임

#### CG vs CA

- cg는 cpu가 램에 비트맵을 직접 계산해서 넣는 것 이 비트맵을 gpu가 같은 주소에서 읽어옴(벡터연산, 텍스트 렌더링에 강점)
  - draw안에서 복잡한 cg는 하면안됨, 무거움
- ca는 cpu가 속성을 변경하면 gpu가 그것을 조합해서 비트맵을 만듬
  - cpu부하가 매우적고 부드러움, offscreen rendering, shouldRasterize=true를 사용하여 잘 안변하는 레이어는 비트맵 캐싱
-  복잡한 이미지 합성이나 정교한 픽셀조작은 Core Graphics를 백그라운드에서 연산한다.
-  단순한 이동이나 투명도 변화같은 ui 인터랙션은 ca에 맡긴다.



### CPU와 메모리 간의 데이터 교환은 어떻게 이루어지나요?



데이터 교환 속도를 높이기 위해 컴퓨터 시스템에는 어떤 장치들이 사용되나요?
버스(Bus)란 무엇이며, 어떤 종류가 있나요?
CPU와 RAM 외에 버스를 통해 연결되는 다른 장치들은 무엇이 있을까요?
캐시 메모리의 개념과 역할에 대해 설명해주세요.
캐시 히트(Cache Hit)와 캐시 미스(Cache Miss)는 무엇이며, 성능에 어떤 영향을 미치나요?
