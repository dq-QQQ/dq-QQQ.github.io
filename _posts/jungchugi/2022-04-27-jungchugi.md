---
title: 정보처리기사 요약
categories: 
  - certification
excerpt: "정보처리기사의 주요 개념을 요약해봤다:)"
date: 2022-04-27
tags:
- certification
- 정보처리기사
---

# 개요

시나공 정보처리기사 실기 책을 기반으로 한 개념정리

필기에 나온 개념은 실기에도 나올 확률이 높기 때문에 문제 유형을 정리하고

각 장마다 핵심개념을 요약한다.

<br />
<br />

---

# 2022 1회차 필기 문제 유형

---

1. 사용자 인터페이스
2. 애자일 방법론
3. 요구사항 분석 특징
4. 객체지향
5. 통합 테스트(하향식, 상향식)
6. 자료흐름도
7. 모델링
8. UML
9. UI 설계 도구
10. 스크럼
11. UML
12. LOC
13. 클래스 설계 원칙
14. GoF 디자인 패턴
15. 아키텍쳐 설계과정
16. 사용자 인터페이스
17. 디자인 패턴
18. 객체지향 분석기법
19. FEP
20. 객체지향
21. 클린코드
22. 단위 테스트
23. 스택
24. 모듈화 장점
25. 프로젝트 관리
26. 정형 기술 검토
27. 소프트웨어 재공학
28. 프로그래밍 언어선택
29. 소프트웨어 패키징
30. 선형 자료구조
31. Alien Code
32. 소프트웨어 재사용
33. 인터페이스 통신 데이터 포맷
34. NS 차트
35. 스택
36. 정렬알고리즘
37. 화이트 박스 검사기법
38. ISO/IEC 25000
39. 코드 인스펙션
40. 위험분석(Risk Analysis)
41. 데이터베이스 물리적 설계
42. Delete 명령어
43. 정규화 과정
44. E-R 다이어그램
45. DB의 키
46. 관계해석
47. Degree Cardinality
48. 뷰
49. 관계대수
50. 정규화 과정
51. Create Table
52. SQL 특징
53. SQL 실행결과
54. BETWEEN과 같은거
55. 트랜잭션(롤백)
56. DCL 데이터 제어어
57. SQL 실행결과
58. 분산 데이터베이스 시스템
59. SQL 실행결과
60. DB 병행제어
61. IP 주소체계
62. C언어 실행결과
63. OSI 7 LAYERs
64. C언어 연산자
65. IPv6
66. 자바 예외
67. TCP/IP ARP 프로토콜
68. 결합도 응집도
69. 임계구역 접근 제어 상호배제기법
70. 모듈
71. Best Fit
72. C언어 실행결과
73. 자바 실행결과
74. 빌드 도구
75. FIFO 알고리즘
76. C언어 실행결과
77. 파이썬 실행결과
78. C언어 실행결과
79. 파이썬 실행결과
80. 쉘 기능
81. 나선형 모델
82. HACMP(고가용성 솔루션)
83. Switch Jamming
84. 스토리지 시스템 DAS
85. 취약점 관리
86. V 모델
87. 블루투스
88. DoS 공격
89. Honeypot
90. 도커
91. 간트차트
92. CrawlCat
93. Secure 코딩 입력데이터의 보안약점
94. 파일시스템(FAT,NTFS)
95. DES 알고리즘
96. 리눅스 umask
97. 리눅스 로그파일(wtmp)
98. LOC
99. DPI 패킷분석기술
100. 테일러링



<br />
<br />

---

# 1장-요구사항 확인

---

<br />

## 소프트웨어 생명주기

---

* 폭포수 모형
* 프로토타입 모형
* 나선형 모형
* 애자일 모형

<br />

---

## 폭포수 모형

---

각 단계를 확실히 끝내고 다음 단계를 진행


<br />

---

## 프로토타입 모형

---

개발될 소프트웨어의 견본품을 만들어 최종 결과물을 예측

<br />

---

## 나선형 모형

---

여러번의 소프트웨어 개발과정을 거쳐 점진적으로 개발

`계획수립` -> `위험 분석` -> `개발 및 검증` -> `고객 평가`

<br />

---

## 애자일 모형

---

고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발

폭포수와 대조적

<br />

---

### 애자일 핵심가치

---

* 프로세스와 도구보다 개인과의 상호작용 중시
* 문서보다 실행되는 소프트웨어 중시
* 계약 협상보다는 고객과 협업 중시
* 계획을 따르기보다 변화에 반응 중시

<br />

---

## 스크럼

---

팀이 중심이 되어 개발의 효율성을 높이는 기법

<br />

---

## XP(eXtreme Programming)

---

고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발과정의 반복을 통해 생산성을 향상시키는 기법

<br />

---

### XP의 5가지 핵심가치

---

* 의사소통
* 단순성
* 용기
* 존중
* 피드백 

<br />

---

### XP의 12가지 실천방법

---

* pair Programming
* collective ownership
* test-driven development
* whole team
* continuous integration
* refactoring
* small releases
* planning game
* design improvement
* coding standards
* simple design
* system metaphor
* sustainable pace

<br />

---

## 운영체제

---

컴퓨터 자원을 효율적으로 관리하고, 사용자가 컴퓨터를 편리하게 사용할 수 있게 해주는 소프트웨어

<br />

---

### 고려사항

---

* 가용성
* 성능
* 기술지원
* 주변기기
* 구축비용

<br />

---

## DBMS

---

사용자와 DB 사이에서 정보를 생성해주고 DB를 관리해주는 소프트웨어

<br />

---

### 고려사항

---

* 가용성
* 성능
* 기술 지원
* 상호 호환성
* 구축 비용

<br />

---

## 웹 어플리케이션 서버(WAS)

---

동적인 컨텐츠를 처리하기 위해 사용되는 미들웨어

<br />

---

## 요구사항

---

소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 운영되는데 필요한 제약조건

<br />

---

### 요구사항 유형

---

* 기능 요구사항
* 비기능 요구사항
* 사용자 요구사항
* 시스템 요구사항

<br />

---

## 요구사항 개발 프로세스

---

`도출` -> `분석` -> `명세` -> `확인`

<br />

---

## 요구사항 분석

---

자료흐름도

자료사전

<br />

<figure>
	<a href="https://user-images.githubusercontent.com/79088896/165488949-614706a1-17e9-4ed9-a133-ff715938130b.jpeg">
		<img src="https://user-images.githubusercontent.com/79088896/165488949-614706a1-17e9-4ed9-a133-ff715938130b.jpeg" class="w8" />
	</a>
</figure>


<br />

---

## UML

---

시스템 개발 과정에서 의사소통이 원활하게 이루어지도록 표준화한 객체지향 모델링 언어

<br />

---

## UML 구성 요소

---

* 사물
* 관계
* 다이어그램

<br />

---

## UML 관계

---

사물과 사물 사이의 연관성을 표현

* 연관(Association) : 서로 관련이 있는 관계 (숫자써있으면)
* 집합(Aggregation) : 서로 독립적인 포함관계 (마름모)
* 포함(Composition) : 서로 독립되지 않은 포함관계 (색칠된 마름모)
* 일반화(Generalization) : 일반적이거나 구체적인 관계 (선과 삼각형 화살표 위 아래로)
* 의존(Dependency) : 서로에게 영향을 줄때면 연관을 유지하는 관계 (점선 , 화살표)
* 실체화(Realization) : 할 수 있거나 해야하는 기능 (점선과 삼각형 화살표 위 아래로)

<br />

---

## UML 다이어그램

---

사물과 관계를 도형으로 표현한 것

<br />

---

## 구조적 다이어그램

---

* 클래스 : 클래스 관계
* 객체 : 객체와 객체들의 관계, 럼바우 객체 모델링에 활용
* 컴포넌트 : 컴포넌트 관계 (구현단계에서 사용)
* 배치 : 물리적 요소들의 위치 (구현단계에서 사용)
* 복합체 구조 : 복합 구조
* 패키지 : 모델 요소들을 그룹화한 패키지들의 관계

<br />

---

## 행위 다이어그램

---

* 유스케이스 : 사용자의 요구
* 시퀀스 : 상호작용하는 시스템이나 객체들이 주고받는 메시지
* 커뮤니케이션 : 동작에 참여하는 객체들간의 연관관계
* 상태 : 상태 변화, 럼바우 동적 모델링에서 사용
* 활동 : 처리의 흐름을 순서에 따라 표현
* 상호작용 개요 : 상호작용
* 타이밍 : 객체상태변화와 시간제약을 명시적으로 표현

<br />

---

## 스테레오 타입

---

기본 기능외에 추가적인 기능을 표현하는 것

`<< >>`


<br />

---

## 소프트웨어 재사용

---

이미 개발되어 인정받은 소프트웨어를 다른 소프트웨어 개발이나 유지에 사용하는 것

* 합성 중심 : 블록을 만들어서 끼워맞추는 것
* 생성 중심 : 명세를 구체화하여 만드는 것

<br />

---

## 소프트웨어 재공학

---

기존 시스템을 이용하여 나은 시스템을 구축하고, 새로운 기능을 추가해서 성능을 향상시키는 것

<br />

---

## CASE

---

Computer Aided Software Engineering

소프트웨어 개발 과정에서 사용되는 과정을 컴퓨터와 도구를 사용하여 자동화 하는 것

<br />

---

## 하향식 비용 산정 기법

---

과거의 경험을 바탕으로 개발자들이 회의를 통해 비용을 산정하는 기법

<br />

---

## 델파이 기법

---

많은 전문가의 의견을 종합하여 산정하는 기법

<br />

---

## 상향식 비용 산정 기법

---

세부적인 작업 단위별로 비용을 산정한 후 집계하여 전체 비용을 산정하는 기법

<br />

---

## LOC

---

* 노력 = 기간 X 인원 = LOC / 1인당 월평균 라인 수
* 비용 = 노력 X 1인당 인건비
* 기간 = 노력 / 인원
* 생산성 = LOC / 노력

<br />

---

## 수학적 산정 기법

---

상향식 비용 산정 기법

* COCOMO
* Putnam
* 기능 점수 모형

<br />

---

## COCOMO 모형

---

LOC에 의한 비용 산정기법

<br />

---

## COCOMO 개발 유형

---

* 조직형(organic) : 중.소 규모의 소프트웨어, 5만 라인 이하
* 반분리형(Semi-Detached Mode) : 중간 규모의 소프트웨어, 30만 라인 이하
* 내장형(Embedded Mode) : 대규모의 소프트웨어, 30만 라인 이상

<br />

---

## Putnam 모형

---

소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 예상하는 모형

Rayleigh-Norden 곡선의 노력분포도를 기반으로 함


<br />

---

## 기능 점수 모형

---

소프트웨어의 기능을 증대시키는 요인별로 기능 점수를 구한 후 비용을 산정하는 기법

<br />

---

## 소프트웨어 개발 표준

---

소프트웨어 개발 단계에서 수행하는 품질 관리에 사용되는 국제 표준

* ISO/IEC 12207
* CMMI
* SPICE

<br />

---

## ISO/IEC 12207

---

ISO에서 만든 표준 소프트웨어 생명 주기 프로세스

<br />

---

## CMMI

---

소프트웨어 개발 조직의 업무능력 및 성숙도를 평가하는 모델

`초기` -> `관리` -> `정의` -> `정량적 관리` -> `최적화`


<br />

---

## SPICE

---

소프트웨어의 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준

`불완전` -> `수행` -> `관리` -> `확립` -> `예측` -> `최적화`


<br />

---

## 소프트웨어 개발 프레임워크

---

소프트웨어 개발에 공통적으로 사용되는 구성요소와 아키텍쳐를 일반화하여 제공해주는 반제품형태의 소프트웨어


<br />

---

### 소프트웨어 개발 프레임워크 특징

---

* 모듈화 
* 재사용성 
* 확장성
* 제어의 역흐름

<br />
<br />

---

# 2장-데이터 입출력 구현

---

<br />

## 데이터베이스

---

공동으로 사용될 데이터를 중복을 배제하여 통합하고 저장장치에 저장하여 사용할 수 있도록하는 운영 데이터

<br />

---

## DBMS

---

사용자의 요구에 따라 정보를 생성해주고, DB를 관리해주는 소프트웨어


<br />

---

## DBMS 필수기능

---

* 정의(definition)
* 조작(Manipulation)
* 제어(Control)


<br />

---

## 스키마

---

데이터베이스의 구조와 제약조건에 관한 전반적인 명세를 기술한 것


<br />

---

## 스키마 종류

---

* 외부 스키마 : 개인의 입장에서의 논리적 구조
* 개념 스키마 : DB의 전체적인 논리적 구조
* 내부 스키마 : 물리적 저장장치 입장에서 본 DB구조


<br />

---

## 데이터 베이스 설계 순서

---

`요구 조건 분석` -> `개념적 설계` -> `논리적 설계` -> `물리적 설계` -> `구현`


<br />

---

### 요구 조건 분석

---

DB를 필요한 용도를 파악하는 것


<br />

---

### 개념적 설계

---

정보 모델링

현실세계에 대한 인식을 추상적 개념으로 표현하는 과정


<br />

---

### 논리적 설계

---

데이터 모델링

현실 세계에서 발생하는 자료를 DBMS가 지원하는 논리적 자료구조로 변환시키는 과정


<br />

---

### 물리적 설계

---

데이터 구조화

논리적 구조로 표현된 데이터를 물리적 구조의 데이터로 변환하는 과정


<br />

---

### 구현

---

논리적 설계와 물리적 설계에서 도출된 데이터베이스 스키마를 파일로 생성하는 과정


<br />

---

## 데이터 모델

---

현실세계의 정보들을 체계적으로 표현한 개념적 모형


<br />

---

### 데이터 모델에 표시할 요소

---

* 구조
* 연산
* 제약 조건


<br />

---

## E-R 다이어그램

---

* 사각형 : 개체 타입
* 마름모 : 관계 타입
* 타원 : 속성
* 이중 타원 : 다중값 속성
* 밑줄 타원 : 기본키 속성
* 복수 타원 : 복합 속성
* 관계 : 개체간 관계
* 선, 링크 : 개체 타빙과 속성을 연결


<br />

---

## 관계형 데이터베이스

---

테이블을 이용해서 데이터 상호관계를 정의하는 데이터 베이스


<br />

---

### 관계형 데이터베이스 구조

---

* 튜플 : 릴레이션을 구성하는 각각의 행 cardinality
* 속성 : 데이터베이스를 구성하는 가장 작은 논리적 단위(열) degree, 차수
* 도메인 : 하나의 속성이 가지는 값들의 집합

<br />

---

## 관계형 데이터베이스의 키

---

* 주키(primary key) : 후보키 중에서 특별히 선정된 키
* 후보키(candidate key) : 속성들중에서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합(유일성 최소성 만족)
* 대체키(alternate key) : 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키
* 슈퍼키(super key) : 속성들의 집합으로 구성된 키
* 외래키(foreign key) : 다른 릴레이션의 기본키를 참조하는 속성

<br />

---

## 관계형 데이터베이스의 무결성

---

* 개체무결성 : 기본 테이블의 기본키를 구성하는 어떤 속성도 NULL값이나 중복값을 가질 수 없다는 규정
* 참조무결성 : 외래키 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일해야함

<br />

---

## 관계대수

---

원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는 가를 기술하는 절차적인 언어

<br />

---

### 순수 관계연산자

---

* select : 튜플추출 , σ(시그마)
* project : 속성추출 , ㅠ(파이)
* Join : 릴레이션 두개 합침 , ㅣ><ㅣ
* division : 나머지 , %

<br />

---

## 이상(anomaly)

---

테이블에서 데이터의 중복이 발생하고 이 중복으로 릴레이션 조작 시 문제가 발생하는 현상

<br />

---

### 이상 종류

---

* 삽입 이상
* 삭제 이상
* 갱신 이상

<br />

---

## 정규화

---

중복을 제거하여 테이블을 무손실 분해하는 과정

<br />

---

### 정규화 과정

---

<br />

<figure>
	<a href="https://user-images.githubusercontent.com/79088896/165542412-b5ded3d1-5901-462b-816f-9752c537ee85.jpeg">
		<img src="https://user-images.githubusercontent.com/79088896/165542412-b5ded3d1-5901-462b-816f-9752c537ee85.jpeg" class="w8" />
	</a>
</figure>

<br />

---

## 반정규화

---

정규화된 데이터 모델을 의도적으로 통합 중복하여 정규화 원칙을 위배하는 행위

<br />

---

## 시스템 카탈로그

---

다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스

<br />

---

## 트랜잭션

---

논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산

<br />

---

### 트랜잭션의 특성

---

* 원자성(Atomicity) : 커밋되던지 롤백되던지
* 일관성(Consistency) : 실행을 완료하면 일관성있는 상태로 변환
* 독립성(Isolation) : 동시에 트랜잭션이 실행되면 서로 끼어들 수 없음
* 지속성(Durability) : 시스템이 고장나도 영구적으로 반영되어야 함

<br />

---

## 인덱스

---

데이터 레코드를 빠르게 접근하기 위해 키밸류 쌍으로 구성되는 데이터 구조

<br />

---

## 뷰

---

하나 이상의 기본 테이블로부터 유도된 가상 테이블

<br />

---

## 클러스터

---

동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법

<br />

---

## 파티션

---

대용량의 테이블이나 인덱스를 작은 논리적 단위로 나누는 것

<br />

---

### 파티션 종류

---

* 범위분할 : 지정한 열의 값을 기준으로 분할
* 해시분할 : 해시함수를 적용한 결과 값에 따라 분할
* 조합분할 : 범위 + 해시 분할

<br />

---

## 데이터 베이스 접근통제

---

* 임의 접근통제(DAC) : 사용자의 신원에 따라 접근권한 부여
* 강제 접근통제(MAC) : 주체와 객체의 등급을 비교하여 접근권한 부여
* 역할기반 접근통제(RBAC) : 사용자의 역할에 따라 접근권한 부여

<br />
<br />

---

# 3장-통합구현 없음

---



<br />
<br />

---

# 4장 - 서버 프로그램 구현

---

<br />


## 소프트웨어 아키텍쳐

---

소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조

<br />

---

### 소프트웨어 아키텍쳐 설계의 기본원리

---

* 모듈화 : 시스템의 기능들을 모듈단위로 나누는 것
* 추상화 : 전체적이고 포괄적인 개념을 설계한 후 구체화시켜 나가는 것
* 단계적 분해 : 상위의 중요개념으로부터 하위의 개념으로 구체화시키는 분할 기법
* 정보 은닉 : 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법

<br />

---

## 객체지향

---

요소들을 객체로 만든후 객체들을 조립해서 소프트웨어를 개발하는 기법

<br />

---

### 클래스

---

공통된 속성과 연산을 갖는 객체의 집합

<br />

---

### 메시지

---

객체들간의 상호작용에 사용되는 수단

<br />

---

### 캡슐화(Encapsulation)

---

인터페이스를 제외한 세부 내용을 은닉하는 것

<br />

---

### 상속(Inheritance)

---

상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것

<br />

---

### 다형성(Polymorphism)

---

하나의 메시지에 대해 각각의 객체가 고유한 방법으로 응답할 수 있는 능력

<br />

---

## 객체지향 분석

---

사용자의 요구사항과 관련된 객체, 속성, 연산, 관계등을 정의하여 모델링하는 작업

<br />

---

## 럼바우 분석기법

---

모든 소프트웨어 구성요소를 그래픽 표기법을 이용하여 모델링하는 기법

<br />

---

## 럼바우 분석활동

---

* 객체 모델링 : 객체 다이어그램으로 표시
* 동적 모델링 : 상태 다이어그램으로 표시
* 기능 모델링 : 자료 흐름도로 표시

<br />

---

## Coad와 Yourdon 기법

---

E-R 다이어그램을 사용하여 모델링

<br />

---

## 모듈

---

모듈화를 통해 분리된 시스템의 각 기능

모듈의 독립성은 결합도(Coupling)과 응집도(Cohesion)에 의해 측정

<br />

---

## 결합도(Coupling)

---

모듈간에 상호 의존하는 정도

결합도가 약할수록 좋음 강하면 안좋음

결합도 강함(안좋음)

* 내용 : 다른 모듈의 내용을 직접참조 혹은 수정할 때 결합도
* 공통 : 공통 데이터 영역을 여러모듈이 사용할 때의 결합도
* 외부 : 다른 모듈에서 데이터를 참조할 때의 결합도
* 제어 : 다른 모듈의 논리적인 흐름을 제어하는 결합도
* 스탬프 : 모듈간의 인터페이스로 자료구조가 전달될때의 결합도
* 자료 : 모듈간의 인터페이스가 자료요소로만 구성될 때의 결합도

결합도 약함(좋음)

<br />

---

## 응집도(Cohesion)

---

모듈의 내부요소들이 서로 관련되어 있는 정도

응집도가 강할수록 좋음 약하면 안좋음

응집도 약함(안좋음)

* 우연적 : 각 구성 요소들이 서로 관련없는 요소로만 구성된 응집도
* 논리적 : 유사한 성격을 가지는 요소들로 형성된 응집도
* 시간적 : 특정 시간에 처리되는 기능들을 모은 응집도
* 절차적 : 다수에 관련된 기능을 가질때 기능을 순차적으로 수행하는 응집도
* 통신적 : 동일한 입출력을 사용하는 요소들의 응집도
* 순차적 : 출력데이터를 그 다음 활동의 입력데이터로의 응집도
* 기능적 : 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도

응집도 강함(좋음)

<br />

---

## 단위 모듈

---

한가지 동작을 수행하는 기능을 모듈로 구현한 것

<br />

---

### 단위 모듈의 구현 과정

---

`단위 기능 명세서 작성` -> `입출력 기능 구현` -> `알고리즘 구현`

<br />

---

## IPC

---

Inter-Process Communication

모듈 간 통신 방식을 구현하기 위해 사용되는 프로그래밍 인터페이스 집합

<br />

---

### 대표 메소드

---

* shared MEmory
* Socket
* Semaphores
* Pipes&named Pipes
* Message Queueing

<br />

---

## 디자인 패턴

---

모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식

GOF의 디자인 패턴은 생성 패턴, 구조 패턴, 행위 패턴으로 구분된다.

<br />

---

## 생성패턴

---

클래스나 객체의 생성과 참조 과정을 정의하는 패턴

* 추상 팩토리(Abstract Factory) : 구체적인 클래스에 의존하지 않고 객체들의 그룹으로 추상적으로 표현함
* 빌더 : 조합하여 객체를 생성
* 팩토리 메서드 : 생성을 서브클래스에서, 캡슐화한 패턴
* 프로토타입 : 원본 객체 복제
* 싱글톤 : 하나의 객체 생성시 동시에 참조 불가능

<br />

---

## 구조패턴

---

클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴

* 어댑터 : 호환성 있게 해주는 패턴
* 브리지 : 구현부에서 추상층을 분리한 패턴
* 컴포지트 : 여러 객체를 다루고자 하는 패턴
* 데코레이터 : 객체 간의 결합을 통해 기능을 확장할 수 있는 패턴
* 퍼싸드(Facade) : 상위에 인터페이스를 구성한 패턴
* 플라이웨이트(Flyweight) : 인스턴스 공유 메모리절약
* 프록시(Proxy) : 객체 사이 연결 인터패이스 패턴


<br />

---

## 행위 패턴

---

클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴

* 책임 연쇄(Chain of Responsibility) : 요청을 처리할 수 있는 객체 책임 연쇄
* 커맨드 : 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
* 인터프리터 : 언어에 문법표현을 정의하는 패턴
* 반복자(Iterator) : 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하는 패턴
* 중재자(Mediator) : 객체의 상호작용을 캡슐화
* 메멘토(Memento) : 특정 시점의 상태로 돌릴수 있는 패턴
* 옵서버(Observer) : 상태가 변화하면 상속된 객체에 변화된 상태를 전달하는 패턴
* 상태(State) : 동일한 동작을 다르게 처리해야할 때 사용하는 패턴
* 전략(Strategy) : 동일한 계열의 알고리즘들을 캡슐화하여 교환할 수 있게하는 패턴
* 템플릿 메서드(Template Method) : 상위 클래스에서 골격정의 하위클래스에서 구체화
* 방문자(Visitor) : 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴

<br />
<br />

---

# 5장 - 인터페이스 구현

---

<br />


## 요구사항 검토

---

* 동료검토 : 명세서 작성자가 설명하고 동료들이 검토하는 방법
* 워크스루 : 검토 회의 전에 명세서를 미리 배포하여 사전 검토 후에 검토 회의를 통해 결함을 발견하는 형태
* 인스펙션 : 명세서 작성자를 제외한 다른 전문가들이 검토하는 방법

<br />

---

## 미들웨어

---

운영체제와 응용 프로그램 사이에서 서비스를 제공하는 소프트웨어

<br />

---

## EAI

---

Enterprise Application Integration

기업 내 각종 어플리케이션 및 플랫폼 간의 상호 연동이 가능하게 해주는 솔루션

* Point-to-Point : 1대1로 연결
* Hub & Spoke : 중앙 집중형 방식
* Message Bus(ESB) : 어플리케이션 사이에 미들웨어
* Hybrid : Hub&Spoke + Message Bus

<br />

---

## 웹서비스

---

네트워크 정보를 표준화된 서비스 형태롤 만들어 공유하는 기술

* SOAP : 네트워크 상에서 HTTP/HTTPS, SMTP등을 이용하여 XML을 교환하기 위한 통신 규약
* WSDL : 웹 서비스나 관련된 서식이나 프로토콜 등을 표준적인 방법으로 기술하고 게시하기 위한 언어
* UDDI : WSDL을 등록하여 서비스와 서비스 제공자를 검색하고 접근하는데 사용

<br />

---

## 인터페이스 구현

---

송수신 시스템 간의 데이터 교환 및 처리를 실현해 주는 작업

* XML : 특수한 목적을 갖는 마크업 언어를 만드는 데 사용되는 다목적 마크업 언어
* JSON : 데이터 객체를 속성 값의 쌍 형태로 표현하는 개방형 표준 포맷
* AJAX : 클라이언트와 서버 간에 XML 데이터를 주고받는 비동기 통신기술


<br />

---

## 인터페이스 구현 검증 도구

---

* xUnit : 자바 , c등 단위 테스트 프레임워크
* STAF : 서비스 호출 및 컴포넌트 재사용을 지원하는 테스트 프레임워크
* FitNesse : 웹기반 테스트 프레임워크
* NTAF : FitNesse + STAF
* Selenium : 웹어플리케이션 테스트 프레임워크
* watir : RUBY 기반 어플리케이션 테스트 프레임워크


<br />
<br />

---

# 6장 - 화면 설계

---

<br />



## 사용자 인터페이스

---

사용자와 시스템 간의 상호작용이 이루어지도록 도와주는 소프트웨어

<br />

---

## 사용자 인터페이스 구분

---

* CLI(Command Line interface) : 명령과 출력이 텍스트 형태
* GUI(Graphical User Interface) : 아이콘이나 메뉴와 같이 그래픽 환경
* NUI(Natural User Interface) : 사용자의 말이나 행동으로 조작

<br />

---

## 사용자 인터페이스 기본 원칙

---

* 직관성 : 누구나 쉽게 이해하고 사용할 수 있어야 함
* 유효성 : 사용자의 목적을 정확하고 완벽하게 달성해야함
* 학습성 : 누구나 쉽게 배우고 익힐 수 있어야함
* 유연성 : 사용자의 요구사항을 수용해야함

<br />

---

## UI 설계 도구

---

* 와이어프레임 : 페이지에 대한 개략적인 뼈대를 설계하는 도구
* 목업(mockup) : 실제화면과 유사하게 만든 정적인 형태의 모형
* 스토리보드 : 와이어프레임에 콘텐츠에 대한 설명등을 추가한 문서
* 프로토타입 : 실제 구현된 것처럼 테스트가 가능한 동적인 형태의 모형
* 유스케이스(Use Case) : 사용자의 요구사항을 기능 단위로 표현


<br />
<br />

---

# 7장 - 어플리케이션 테스트 관리

---

<br />



## 화이트박스 테스트

---

원시코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법

모듈의 모든 문장을 한번 이상 실행하면서 모듈 안의 작동을 직접 관찰

<br />

---

### 화이트박스 테스트 종류

---

* 기초 경로 검사 : 테스트 케이스 설계자가 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 기법
* 제어 구조 검사 : 조건 검사, 루프검사, 데이터 흐름 검사

<br />

---

## 화이트박스 테스트 검증 기준

---

* 문장 검증 기준 : 소스코드의 모든 구문이 한번이상 수행
* 분기 검증 기준 : 모든 조건문의 True와 False 모두 한번 이상 수행
* 조건 검증 기준 : 조건문의 개별 조건 식의 결과가 True False 모두 실행
* 분기/조건 기준 : 분기, 조건 모두 만족


<br />

---

## 블랙박스 테스트

---

각 기능이 완전히 작동되는 것을 입증하는 테스트

요구사항 명세를 보면서 구현된 기능을 테스트

<br />

---

### 블랙박스 테스트 종류

---

* 동치 분할 검사(Equivalence Partitioning Testing) : 맞는 입력과 틀린 입력에 따른 결과가 출력되는지 확인
* 경계값 분석(Boundary Value Analysis) : 입력조건의 경계값으로 테스트
* 원인-효과 그래프 검사(Cause-Effect Graphing Testing) : 입력 데이터 간의 관계와 출력에 영향을 미치는 상황으로 테스트
* 오류 예측 검사(Error Guessing) : 과거의 경험이나 확인자의 감각으로 테스트
* 비교 검사(Comparision Testing) : 여러 버전에 동일한 테스트 동일한 결과 테스트

<br />

---

## V-모델

---

소프트웨어 개발 단계 + 테스트 단계

`요구사항` -> `분석` -> `설계` -> `구현` -> `단위 테스트` -> `통합 테스트` -> `시스템 테스트` -> `인수 테스트`

<br />

---

## 단위 테스트(Unit Test)

---

모듈이나 컴포넌트에 초점을 맞춰 테스트

<br />

---

## 시스템 테스트

---

개발된 소프트웨어가 완벽하게 수행되는가를 점검하는 테스트

<br />

---

## 인수 테스트

---

사용자의 요구사항을 충족하는지에 중점을 두고 테스트

* 알파 테스트 : 개발자의 장소에서 개발자 앞에서 행하는 테스트
* 베타 테스트 : 선정된 사용자가 여러명의 사용자 앞에서 행하는 테스트

<br />

---

## 통합 테스트

---

단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트

<br />

---

### 하향식 통합 테스트

---

상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트

* 깊이우선통합
* 넓이우선통합

주요 제어 모듈은 작성된 프로그램 종속 모듈은 스텁으로 대체

<br />

---

### 상향식 통합 테스트

---

하위모듈에서 상위모듈 방향으로 통합하면서 테스트

하위 모듈들을 클러스터로 결합-> 더미 모듈인 드라이버 작성

* 클러스터 : 하나의 주요 제어 모듈과 종속 모듈의 그룹
* 테스트 드라이버 : 테스트 대상의 하위모듈 호출

<br />

---

## 클린코드

---

누구나 쉽게 이해하고 수정 및 추가할 수 있는 단순 명료한 코드

<br />

---

### 클린코드 작성원칙

---

* 가독성 : 누구든지 코드를 쉽게 읽게
* 단순성 : 코드를 간단하게 작성
* 의존성 배제 : 코드가 다른 모듈에 미치는 영향 최소화
* 중복성 최소화 : 코드의 중복 최소화
* 추상화 : 상위모듈 하위모듈의 경계확실하게



<br />

---

## 외계인코드

---

오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 코드

<br />
<br />

---

# 8장 -SQL 응용

---


<br />


## DDL

---

Data Define Language 데이터 정의어

DB를 구축하거나 수정할 목적으로 사용하는 언어

* CREATE : SCHEMA(AUTHORIZATION), DOMAIN, TABLE, VIEW(AS SELECT), INDEX(ON)를 정의함
* ALTER : TABLE(ADD, ALTER, DROP COLUMN)에 대한 정의를 변경하는 데 사용
* DROP : SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 삭제함

<br />

---

## DCL

---

Data Control Language

데이터의 보안, 무결성, 회복, 병행제어등을 정의하는 데사용하는 언어

* COMMIT : 트랜잭션이 수행한 내용을 데이터베이스에 반영하는 명령
* ROLLBACK : 비정상 종료시 원래의 상태로 복구
* GRANT ~ TO : 사용자에게 사용권한을 부여
* REVOKE ~ FROM : 사용자에게 사용권한을 취소
* SAVEPOINT : 세이브 포인트

<br />

---

## DML

---

* SELECT : 튜플검색
* INSERT INTO ~ VALUE ~ : 튜플추가
* DELETE FROM : 튜플삭제
* UPDATE SET : 튜플갱신
* JOIN : 튜플결합

<br />

---

## SELECT

---

```sql
SELECT [PREDICATE] 속성명 [AS 별칭]
[그룹함수(속성명)]
[Window 함수 OVER ~]
FROM 테이블명
[WHERE 조건]
[GROUP BY 속성명]
[HAVING 조건]
[ORDER BY 속성명 [ASC | DESC]]
```

* PREDICATE : DISTINCT 같은거
* 속성명 : 검색하여 불러올 속성
* AS : 별명
* 그룹함수(속성명) :GROUP BY절에 지정된 그룹별로 속성 값 집계, AVG(급여), MAX(급여)같은거
* WHERE :  검색할 조건
* GROUP BY : 특정 속성을 기준으로 그룹화하여 검색, 그룹함수와 같이쓰임
* HAVING : GROUP BY와 같이 쓰이며 그룹에 대한 조건 지정
* ORDER BY : 데이터를 정렬하여 검색

<br />

---

### SELECT의 조건연산자

---

비교연산자, 논리연산자, LIKE 연산자가 있다.

Like연산자는 문자패턴이 일치하는 튜플을 검색하기 위해 사용

* % : 모든문자 대표
* _ : 문자하나 대표
* # : 숫자하나 대표

<br />

---

## JOIN

---

연관된 튜플들을 결합아혀, 하나의 새로운 릴레이션 반환

<br />

---

### INNER JOIN

---


JOIN 대상 테이블에서 공통 속성을 기준으로 비교에의해 해당하는 행만 연결하는 방법

중복 제거해서 한번만 표기하는 것은 NATURAL JOIN

<br />

---

### OUTER JOIN

---

JOIN 조건에 만족하지 않는 튜플도 결과로 출력

NULL 값이어도 출력

<br />
<br />

---

# 9장 - 소프트웨어 개발 보안 구축

---


<br />


## 소프트웨어 개발 보안 요소

---

* 기밀성(Confidentiality) : 정보와 자원은 인가된 사용자에게만 접근이 허용됨
* 무결성(Integrity) : 정보는 인가된 사용자만 수정할 수 있음
* 가용성(Availability) : 인가받은 사용자는 시스템 내의 정보와 자원을 언제라도 사용가능함


<br />

---

## 암호 알고리즘

---

중요정보를 보호하기 위해 평문을 암호화된 문장으로 만드는 방법


<br />

---

### 양방향 알고리즘 종류

---

* SEED : 한국 인터넷진흥원에서 개발한 블록 암호화 알고리즘 블록크기 : 128비트
* ARIA : 국정원과 산학연협회가 개발한 블록암호화 알고리즘
* DES : NBS에서 만든 개인키 암호화 알고리즘 64비트
* AES : NIST에서 만든 개인키알고리즘 128비트
* RSA(Rivest Shamir Adleman) : MIT에서 만든 공개키 암호화 알고리즘


<br />

---

### 단방향 알고리즘

---

* 해시 : 임의의 길이의 입력데이터나 메시지를 고정된 길이의 값이나 키로 변환


<br />

---

## 서비스 공격

---

* Dos(Denial of Service) : 대량의 데이터를 한곳으로 집중적으로 전성해서 서버를 마비
* Ping of Death : 패킷의 크기를 인터넷 프로토콜 허용 범위 이상으로 전송해서 네트워크 마비
* SMURFING : 엄청난 양의 데이터를 한 사이트에 집중적으로 보내서 네트워크 마비
* SYN Flooding : 3-way-handshake를 의도적으로 중단해서 대기상태로 유지하게하는 것
* TearDrop : Offset 값을 변경시켜 수신 측에 과부하를 발생시켜 시스템 다운 유도
* Land Attack :  패킷을 전송할 때 송신 IP 주소와 수신 IP 주소를 모두 공격 대상의 IP 주소로 바꿔서 자신에게 무한 루프
* DDoS : 여러 곳에서 한곳의 서버에 분산 서비스 공격
* Session Hijacking : 세션 정보를 가로채는 기법
* ARP Spoofing : 자신의 MAC을 공격대상의 것으로 변조해서 데이터 패킷을 가로챔
* Smishing : SMS를 이용해 사용자의 개인 신용정보를 빼내는 수법
* Spear Phishing : 이메일 링크로 개인정보 탈취
* APT : 활동거점 만들고 기다리다 공격
* 무작위 대입 공격 : 모든값 다 넣기
* Qshing : QR코드 악성프로그램 다운 유도
* SQL Injection : DB의 데이터 조작 공격방식
* Sniffing : 패킷의 정보를 도청
* Key Logger Attack : 키보드 움직임을 탐지해 정보탈취
* Ransomware : 컴퓨터 문서 파일을 암호화
* Back Door : 시스템 보안을 제거하여 만들어놓은 비밀 통로
* 트로이 목마(Trojan Horse) : 정상적인 기능으로 위장 나중에 활성화

 <br />
<br />

---

# 10장 - 프로그래밍 언어 활용

---


<br />


## 자바 예외처리

---

예외 처리는 예외가 발생했을 때 프로그래머가 해당 문제에 대비해 작성해 놓은 루틴이다.

예외를 객체로 취급하며 관련된 클래스를 java.lang 패키지에서 제공

try ~ catch문으로 예외처리

```java
try { 
   예외가 발생할 가능성이 있는 코드;
}
catch (예외 객체1) { 
   예외발생시 처리코드
}
*
*
catch (Exception 매개변수) {
   위의 예외에 없는 예외 처리코드
}
finally { 
   예외랑 상관 없는 코드
}
```

 <br />
<br />

---

# 11장 - 응용 SW 기초 기술 활용

---


<br />


## 메모리 관리 배치 전략

---

프로그램이나 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정

* First Fit : 데이터가 들어갈 수 있는 첫번째 영역
* Best Fit : 데이터가 들어갈 수 있는 영역중 가장 작게 남기는 영역
* Worst Fit : 데이터가 들어갈 수 있는 영역중 가장 많이 남기는 영역

<br />

---

## 페이지 교체 알고리즘 - FIFO

---

First In First Out으로 메모리에 적재될 때 시간을 기억하고 가장 오래있었던 페이지를 교체하는 기법

<br />

---

## IPv6

---

128비트

인증성, 기밀성, 데이터 무결성의 지원

<br />

---

## IPv6의 주소체계

---

* Unicast : 1대1 통신
* Multicast : 1대다 통신
* Anycast : 1대1 통신(가장 가까이있는 수신자)



<br />

---

## 프로토콜

---

데이터 교환을 원활하게 수행할 수 있도록 표준화 시켜 놓은 통신 규약

Syntax, Semantics, Timing이 있어야함


<br />

---

## TCP/IP

---

서로 다른 기종의 컴퓨터들이 데이터를 주고받을 수 있도록 하는 프로토콜

* 응용 계층 : 응용 프로그램 간의 데이터 송수신 
* 전송 계층 : 호스트들 간의 신뢰성 있는 통신
* 인터넷 계층 : 데이터 전송을 위한 주소 지정, 경로 설정
* 네트워크 액세스 계층 : 실제 데이터를 송수신


<br />

---

## 응용계층 프로토콜

---

* FTP(File Transfer Protocal) : 원격 파일 전송 프로토콜
* SMTP(Simple Mail Transfer Protocol) : 전자 우편
* TELNET : 원격접속
* SNMP(Simple Network Management Protocal) : 네트워크 관리 프로토콜
* DNS(Domain NAme System) : 도메인 이름 IP주소 매핑
* HTTP(HyperText Transfer Protocal) : www에서 HTML 문서 송수신 프로토콜


<br />

---

## 전송계층 프로토콜

---

* TCP(Transmission Control Protocal) : 신뢰성 있는 전송
* UDP(User Datagram Protocal) : 신뢰성 없는 전송


<br />

---

## 인터넷 계층 프로토콜

---

* IP(Internet Protocal) :  전송할 데이터의 주소를 지정하고 경로를 설정
* ICMP(Internet Control Message Protocal) : IP와 조합에서 제어메시지 관리
* ARP(Address Resolution Protocal) : 호스트의 IP주소를 네트워크 접속 장치의 물리적 주소로 바꿈
* RARP(Reverse Address Resolution Protocal) : 물리적 주소를 IP주소로

<br />

---

## 네트워크 액세스 계층 프로토콜

---

* Ethernet(IEEE 802.3) : CSMA/CD 방식의 LAN
* IEEE 802 : LAN을 위한 표준 프로토콜


<br />

---

## 경로제어 프로토콜

---

전송 경로중에서 최적 패킷 교환 경로를 결정하는 것

* RIP(Routing Information Protocal) :  거리백터 라우팅 프로토콜 Bellman-Ford 알고리즘, 15홉수 안으로 도달 따라서 소규모
* OSPF(Open Shortest Path First protocal) : RIP의 단점 보완, 대규모 네트워크, 다익스트라
* EGP(Exterior) : 자율 시스템 간의 라우팅에 사용되는 프로토콜

 <br />
<br />

---

# 12장 - 제품 소프트웨어 패키징

---


<br />


## 소프트웨어 패키징

---

모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것

`기능 식별` -> `모듈화` -> `빌드진행` -> `사용자 환경 분석` -> `패키징 및 적용시험` -> `패키징 변경 개선` -> `배포`

<br />

---

## 디지털 저작권 관리 구성요소

---

* 클리어링 하우스 : 저작권에 대한 결제 관리를 수행하는 곳
* 컨텐츠 제공자 
* 패키저 : 컨텐츠를 메타데이터와 묶어 암호화
* 컨텐츠 분배자 : 유통
* 컨텐츠 소비자 
* DRM 컨트롤러 : 배포된 컨텐츠의 이용권한 통제
* 보안 컨테이너 : 원본을 안전하게 유통하기 위한 보안장치

<br />

---

## 디지털 저작권 관리 기술 요소

---

* 암호화
* 키 관리
* 암호화 파일 생성
* 식별 기술
* 저작권 표현
* 정책 관리
* 크랙 방지
* 인증

<br />

---

## 형상관리

---

개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 활동



<br />

---

## 빌드 자동화 도구

---

빌드를 포함하여 테스트 및 배포를 자동화하는 도구

* Jenkins : JAVA 기반의 오픈 소스, 서블릿 컨테이너에서 실행되는 서버 기반 도구
* Gradle : Groovy를 기반으로 한 오픈 소스 형태의 자동화 도구, 안드로이드


